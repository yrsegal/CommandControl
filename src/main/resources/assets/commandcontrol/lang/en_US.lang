# Biome Control
commandcontrol.setbiome.usage=/setbiome <x> <z> <biome>
commandcontrol.setbiome.success=Set the biome at [%d, %d] to %d (%s)
commandcontrol.setbiome.invalid=Biome %s doesn't exist
commandcontrol.setbiome.range=[%d, %d] out of range

commandcontrol.fillbiomes.usage=/fillbiomes <x1> <z1> <x2> <z2> <biome>
commandcontrol.fillbiomes.success=Set the biome from [%d, %d] to [%d, %d] to %d (%s)
commandcontrol.fillbiomes.range=[%d, %d] to [%d, %d] out of range

commandcontrol.testforbiome.usage=/testforbiome <x> <z> [biome]
commandcontrol.testforbiome.match=Biome at [%d, %d] is %d (%s)
commandcontrol.testforbiome.nomatch=Biome at [%d, %d] is %d (%s), expected %d (%s)
commandcontrol.testforbiome.success=Biome at [%d, %d] is %d (%s)
commandcontrol.testforbiome.range=[%d, %d] out of range

commandcontrol.testforbiomes.usage=/testforbiomes <x1> <z1> <x2> <z2> <biome>
commandcontrol.testforbiomes.output=%d matches found from [%d, %d] to [%d, %d] of biome %d (%s)
commandcontrol.testforbiomes.range=[%d, %d] to [%d, %d] out of range

# Data storage
commandcontrol.storedata.usage=/storedata <global|world|slice|pos|tile> ...

commandcontrol.storedata.usage.global=/storedata global <set|add|list|remove|operation|test> ...
commandcontrol.storedata.usage.global.set=/storedata global set <key> <value>
commandcontrol.storedata.usage.global.add=/storedata global add <key> <value>
commandcontrol.storedata.usage.global.remove=/storedata global remove <key>
commandcontrol.storedata.usage.global.test=/storedata global test <key> [min] [max]
commandcontrol.storedata.usage.global.operation=/storedata global operation <key1> <operator> <scope> <key> ...

commandcontrol.storedata.usage.world=/storedata world <set|add|list|remove|test|operation|execute> ...
commandcontrol.storedata.usage.world.set=/storedata world set <key> <value>
commandcontrol.storedata.usage.world.add=/storedata world add <key> <value>
commandcontrol.storedata.usage.world.remove=/storedata world remove <key>
commandcontrol.storedata.usage.world.test=/storedata world test <key> [min] [max]
commandcontrol.storedata.usage.world.operation=/storedata world operation <key1> <operator> <scope> <key> ...

commandcontrol.storedata.usage.slice=/storedata slice <x> <z> <set|add|list|remove|test|operation|listall> ...
commandcontrol.storedata.usage.slice.set=/storedata slice <x> <z> set <key> <value>
commandcontrol.storedata.usage.slice.add=/storedata slice <x> <z> add <key> <value>
commandcontrol.storedata.usage.slice.remove=/storedata slice <x> <z> remove <key>
commandcontrol.storedata.usage.slice.test=/storedata slice <x> <z> test <key> [min] [max]
commandcontrol.storedata.usage.slice.operation=/storedata slice <x> <z> operation <key1> <operator> <scope> <key> ...

commandcontrol.storedata.usage.pos=/storedata pos <x> <y> <z> <set|add|list|remove|test|operation|listall> ...
commandcontrol.storedata.usage.pos.set=/storedata pos <x> <y> <z> set <key> <value>
commandcontrol.storedata.usage.pos.add=/storedata pos <x> <y> <z> add <key> <value>
commandcontrol.storedata.usage.pos.remove=/storedata pos <x> <y> <z> remove <key>
commandcontrol.storedata.usage.pos.test=/storedata pos <x> <y> <z> test <key> [min] [max]
commandcontrol.storedata.usage.pos.operation=/storedata pos <x> <y> <z> operation <key1> <scope> <key> ...

commandcontrol.storedata.usage.tile=/storedata tile <selector> <set|add|list|remove|test|operation|listall> ...
commandcontrol.storedata.usage.tile.set=/storedata tile <selector> set <key> <value> [tag]
commandcontrol.storedata.usage.tile.add=/storedata tile <selector> add <key> <value> [tag]
commandcontrol.storedata.usage.tile.remove=/storedata tile <selector> remove <key>
commandcontrol.storedata.usage.tile.test=/storedata tile <selector> test <key> [min] [max]
commandcontrol.storedata.usage.tile.operation=/storedata tile <selector> operation <key1> <scope> <key> ...

commandcontrol.storedata.notfound=Not found
commandcontrol.storedata.toosmall=Too small
commandcontrol.storedata.toolarge=Too large

commandcontrol.storedata.list.global=Global entries:
commandcontrol.storedata.list.world=Entries for dimension %4$d (%5$s):
commandcontrol.storedata.list.slice=Entries for chunk slice [%1$d, %3$d] in dimension %4$d (%5$s):
commandcontrol.storedata.list.pos=Entries for pos %d, %d, %d in dimension %d (%s):
commandcontrol.storedata.list.tile=Entries for tile at %d, %d, %d in dimension %d (%s):
commandcontrol.storedata.list.entry= %s: %d

commandcontrol.storedata.set=Set %s to %d
commandcontrol.storedata.removed=Removed %s
commandcontrol.storedata.exists=Successfully matched %s

commandcontrol.storedata.autoget.slice=Slice scope needs an X and a Z argument
commandcontrol.storedata.autoget.pos=Pos scope needs an X, Y, and Z argument
commandcontrol.storedata.autoget.tile=Tile scope needs a selector argument
commandcontrol.storedata.autoget.nottile=Tile selector didn't match exactly one
commandcontrol.storedata.autoget.scope.invalid=Invalid scope

commandcontrol.storedata.nomatch=NBT tag doesn't match

commandcontrol.dataexecute.invalidrule=Invalid rule format
commandcontrol.dataexecute.usage=/dataexecute <slice|pos> <rules> <command>

commandcontrol.tselector.invalidrule=Invalid tile selector
